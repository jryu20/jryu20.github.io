{
  "hash": "49cb6ec9dbfa5f7943ca448dd85d1ce5",
  "result": {
    "markdown": "---\ntitle: \"Fun with Regex\"\nauthor: \"Jun Ryu\"\ndate: \"2023-02-21\"\nformat:\n  html:\n    toc: true\ncategories: [R, python, regex]\nimage: \"regex3.png\"\noutput: html_document\n---\n\n\n> Some simple exercises with [regular expressions](https://en.wikipedia.org/wiki/Regular_expression)...\n\n\n\n\n\n## 1. Using R\n\n### names.txt\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- unlist(read.table(\"names.txt\", sep = \"\\n\"), use.names = FALSE)\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"abc123\"          \"horribleTurtle\"  \"messsages\"       \"keep_it_simple\" \n [5] \"hello world!\"    \"Zoran D Wang\"    \"myUsernameis210\" \"abc defg\"       \n [9] \"asml\"            \"john\"            \"Edward Lazowska\" \"123fionaFog\"    \n[13] \"Red chihuahua5\"  \"1\"               \"CLEAN\"           \"+plus+\"         \n[17] \"omaha poshy\"     \"0maha p0shy\"     \"OMAHA POSHY\"    \n```\n:::\n:::\n\n\n#### (a)\n\nFind all usernames that contain at least one numeric character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames[str_detect(names, \"[0-9]\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"abc123\"          \"myUsernameis210\" \"123fionaFog\"     \"Red chihuahua5\" \n[5] \"1\"               \"0maha p0shy\"    \n```\n:::\n:::\n\n\n#### (b)\nFind all usernames that are exactly four characters long and consist only of alphabetic characters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames[str_detect(names, \"^[a-zA-Z]{4}$\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"asml\" \"john\"\n```\n:::\n:::\n\n\n#### (c)\nFind all usernames following the conventional way of name format, i.e., the “given name” goes first, and the “family” name last, with any other names in-between. The names are separated by a single white space and each name should be uppercase letter followed by one or more lowercase letters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames[str_detect(names, \"^(?:[A-Z][a-z]+ )+(?:[A-Z][a-z]+)$\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Edward Lazowska\"\n```\n:::\n:::\n\n\n---\n\n### cards.txt\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncards <- unlist(read.table(\"cards.txt\", sep = \"\\n\"), use.names = FALSE)\ncards\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"5123456789101112\"         \"4789 0123 8910 1112\"     \n [3] \"4444 9321 1230 3\"         \"5315 4011 1721 51\"       \n [5] \"4987 9381 2457\"           \"4891 0870 8908 70987\"    \n [7] \"5234 4567 8910 1112\"      \"58907890782309171\"       \n [9] \"3008 9078 1891 7890\"      \"5192 9295 91828818\"      \n[11] \"4182 2884 1232 9582 2182\"\n```\n:::\n:::\n\n\n---\n\n::: {.callout-note}\n- A Master card number begins with a 5 and it is exactly 16 digits long.\n- A Visa card number begins with a 4 and it is between 13 and 16 digits long.\n:::\n\n#### (a)\nWrite a regex pattern to match valid Master card number and print all the valid numbers, grouped into sets of 4 separated by a single space.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npat_a <- \"^([5][0-9]{3})\\\\s*([0-9]{4})\\\\s*([0-9]{4})\\\\s*([0-9]{4})$\"\napply(str_match(cards[str_detect(cards, pat_a)], pat_a)[,2:5], 1, paste, collapse = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"5123 4567 8910 1112\" \"5234 4567 8910 1112\" \"5192 9295 9182 8818\"\n```\n:::\n:::\n\n\n#### (b)\nWrite a regex pattern to match valid Visa card number and print all the valid numbers, grouped into sets of 4 separated by a single space.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npat_b <- \"^([4][0-9]{3})\\\\s*([0-9]{4})\\\\s*([0-9]{4})\\\\s*([0-9]{1,4})$\"\napply(str_match(cards[str_detect(cards, pat_b)], pat_b)[,2:5], 1, paste, collapse = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"4789 0123 8910 1112\" \"4444 9321 1230 3\"   \n```\n:::\n:::\n\n\n---\n\n### passwords.txt\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasswords <- unlist(read.table(\"passwords.txt\", sep = \"\\n\"), use.names = FALSE)\npasswords\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1234567\"        \"12345678\"       \"Strings78\"      \"appleO07\"      \n [5] \"1brownie\"       \"asdfjkl\"        \"90095\"          \"glhf1234\"      \n [9] \"789afk\"         \"alllowercase\"   \"ALLUPPERCASE\"   \"missingNumbers\"\n```\n:::\n:::\n\n\n#### (a)\nWrite a regex pattern to identify the passwords that satisfies the requirements below.\n\n- Minimum 8 characters\n- Must contain at least one letter\n- Must contain at least one digit\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasswords[str_detect(passwords, \"(?=.*[0-9])(?=.*[a-zA-Z]).{8}\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Strings78\" \"appleO07\"  \"1brownie\"  \"glhf1234\" \n```\n:::\n:::\n\n\n#### (b)\nWrite a regex pattern to identify the passwords that satisfies the requirements below.\n\n- Minimum 8 characters\n- Must contain at least one uppercase character\n- Must contain at least one lowercase character\n- Must contain at least one digit\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasswords[str_detect(passwords, \"(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{8}\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Strings78\" \"appleO07\" \n```\n:::\n:::\n\n\n---\n\n### wordlists.RData\n\nWrite regular expression patterns which will match all of the values in x and none of the values in y.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"wordlists.RData\")\n```\n:::\n\n\n#### (a)\n\n![](regex1.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(str_detect(wordlists$Ranges$x, \"^[a-f]+$\")) == TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(str_detect(wordlists$Ranges$y, \"^[a-f]+$\")) == FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n#### (b)\n\n![](regex2.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(str_detect(wordlists$Backrefs$x, \"([a-z]{3}).*\\\\1\")) == TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(str_detect(wordlists$Backrefs$y, \"([a-z]{3}).*\\\\1\")) == FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n#### (c)\n\n![](regex3.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(str_detect(wordlists$Prime$x, \"^(?!(xx+)\\\\1+$)\")) == TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nany(str_detect(wordlists$Prime$y, \"^(?!(xx+)\\\\1+$)\")) == FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n---\n\n## 2. Using Python\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}