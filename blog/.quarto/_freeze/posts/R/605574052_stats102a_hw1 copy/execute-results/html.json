{
  "hash": "8d79f06d9b2c1543fa13129999cb5be8",
  "result": {
    "markdown": "---\ntitle: \"Homework 1\"\nauthor: \"Jun Ryu\"\ndate: \"2023-01-22\"\noutput: html_document\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(echo = TRUE)\nsource(\"605574052_stats102a_hw1.R\")\n```\n:::\n\n\n## Question 1\n\nPlease write a function, `gcd()`, which takes two arguments x, y and calculates their greatest common divisor (GCD) using the Euclidean algorithm. Make use of `gcd()` to write a function, `lcm()`, which takes a vector and find the least common multiple. The length of the vector will be at least two but no more than 100.\n\n#### **`gcd()`**\n\n**Algorithm:**\n\n1. Check that the inputs are integers.\n\n2. Use absolute value to turn both x and y (the inputs) into positive numbers.\n\n3. Switch x and y (if necessary) so that x is greater than or equal to y.\n\n4. Use the Euclidean algorithm to compute the greatest common divisor.\n\n#### **`lcm()`**\n\n**Algorithm:**\n\n1. Check that the input is a vector with all elements being integers.\n\n2. Grab the first two elements in an array and compute the least common multiple and store it under \"lcm_update\".\n\n3. If there are more elements, we compute our new LCM by finding the LCM of \"lcm_update\" and the next value in the array.\n\n4. Store this new LCM under \"lcm_update\".\n\n5. Repeat Step 3 and 4 until we exhaust the array and return lcm_update.\n\n\n**Test Cases:**\n\n::: {.cell}\n\n```{.r .cell-code}\ngcd(72, 8) # expected output: 8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\ngcd(-1, 531) # expected output: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ngcd(47011, 73618)  # expected output: 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngcd(c(3,5), 7)  # expected output: error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in gcd(c(3, 5), 7): Your inputs must be of length 1\n```\n:::\n\n```{.r .cell-code}\ngcd(26, \"d\") # expected output: error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in gcd(26, \"d\"): Your inputs must be a number\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlcm(c(12, 21)) # expected output: 84\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 84\n```\n:::\n\n```{.r .cell-code}\nlcm(c(4789, 6123, 199)) # expected output: 5835286353\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5835286353\n```\n:::\n\n```{.r .cell-code}\nlcm(c(2,3,4,5,6,15,16)) # expected output: 240\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 240\n```\n:::\n:::\n\n\n\n## Question 2\n\nPlease write a function `get_factors()` which takes a number x and returns a list object. The list object should contain the vector of unique prime factors of x and the corresponding exponents. In addition, write one “helper function” `is_prime()` that returns a logical vector depending on whether or not the elements in x are prime.\n\n#### **`is_prime()`** \n\n**Algorithm:**\n\n1. Check that the elements in the vector are positive integers.\n\n2. Iterate through each element and if the element is 2, declare it a prime.\n\n3. If not, set a temp variable \"end\" to be the element divided by two.\n\n4. Run a for loop from 2 to \"end\" to check if the loop variable perfectly divides the element.\n\n5. If there is one occurrence in the loop where the loop variable divides the element, then declare it a non-prime. Otherwise, declare it a prime.\n\n#### **`get_factors()`** \n\n**Algorithm:**\n\n1. Check that the input is a positive integer.\n\n2. Run a for loop to see which numbers divide our input.\n\n3. Check which of the numbers found in step 2 are prime.\n\n4. Store these primes in the list element named \"primes\".\n\n5. For each of these primes, compute how many times each prime goes into our input.\n\n6. Add these numbers into a list element named \"exponents\".\n\n7. Return the list.\n\n\n**Test Cases:**\n\n::: {.cell}\n\n```{.r .cell-code}\nis_prime(17) # expected output: True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis_prime(c(9, 7, 1)) # expected output: [False True False]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nis_prime(c(10, 2, 601)) # expected output: [False True True]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_prime(20.2)  # expected output: error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in is_prime(20.2): Your inputs must be a positive integer\n```\n:::\n\n```{.r .cell-code}\nis_prime(-30) # expected output: error\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in is_prime(-30): Your inputs must be a positive integer\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_factors(1920) # expected output: list(primes = [2 3 5], exponents = [7 1 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$primes\n[1] 2 3 5\n\n$exponents\n[1] 7 1 1\n```\n:::\n\n```{.r .cell-code}\nget_factors(149625) # expected output: list(primes = [3 5 7 19], exponents = [2 3 1 1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$primes\n[1]  3  5  7 19\n\n$exponents\n[1] 2 3 1 1\n```\n:::\n\n```{.r .cell-code}\nget_factors(3851) # expected output: list(primes = [3851], exponents = [1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$primes\n[1] 3851\n\n$exponents\n[1] 1\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}