{"title":"Objected Oriented Programming in R","markdown":{"yaml":{"title":"Objected Oriented Programming in R","author":"Jun Ryu","date":"2023-03-09","format":{"html":{"toc":true}},"categories":["R","OOP"],"image":"https://upload.wikimedia.org/wikipedia/commons/a/a3/Arithmetic_symbols.svg","output":"html_document"},"headingText":"a) Basics","containsRefs":false,"markdown":"\n\n> Today, we will define \n\n```{r}\nknitr::opts_chunk$set(echo = TRUE)\nsource(\"OOP.R\")\n```\n\n\nTo sum up, you are expected to provide the following functions.\n\n* pqnumber(sign, p, q, nums)\n* is_pqnumber(x)\n* print(x, DEC)\n* as_pqnumber(x, p, q)\n* as_numeric(x)\n\n**Test Cases:**\n```{r}\nx <- pqnumber(1, 3, 4, 1:8)\ny <- pqnumber(1, 6, 0, c(3,9,5,1,4,1,3))\nz <- pqnumber(-1, 5, 1, c(2,8,2,8,1,7,2))\n\nx\ny\nz\n\nis_pqnumber(x) # expected value: TRUE\nis_pqnumber(y) # expected value: TRUE\nis_pqnumber(z) # expected value: TRUE\nis_pqnumber(1230) # expected value: FALSE\n\nprint(x) # expect a pqnumber object (sign = 1, p = 3, q = 4, nums = 1:8)\nprint(y, DEC = T) # expected value: 3.141593\nprint(z, DEC = T) # expected value: -27.18282\n\nas_pqnumber(3.14, 3, 4) # expect a pqnumber object (sign = 1, p = 3, q = 4, nums = c(0,4,1,3,0,0,0,0))\nas_pqnumber(-153.2772, 4, 2) # # expect a pqnumber object (sign = -1, p = 4, q = 2, nums = c(2,7,7,2,3,5,1))\n\nas_numeric(x) # expected value: 87654.321 but it might lose precision\nas_numeric(pqnumber(-1, 3, 6, rep(1,10))) # expected value: -1111111.111 but it might lose precision\n```\n\n## b) Addition and Subtraction\n\n#### **`carry_over()`**\n\n**Algorithm:**\n\n1. We iterate through each element of a numeric vector.\n\n2. We keep the remainder (when divided by 10) in its element spot.\n\n3. We locate the existence of a carry by using %/% and seeing if it is not equal to 0.\n\n4. If it's not equal to 0, we push the carry value onto the next element.\n\n5. We add the carried value to the next element and repeat the process from step 2.\n\n**Test Cases:**\n```{r}\nx <- c(13,4,5)\ny <- c(31,52,9) \n\ncarry_over(x) # expected value: c(3,5,5)\ncarry_over(y) # expected value: c(1,5,4,1)\n\n```\n\n#### **`abs_gtr()`**\n\n**Algorithm:**\n\n1. First, we appropriately pad both numbers by adding extra 0s at the end to either x or y if one has more digits after the decimal point.\n\n2. We do a similar padding by adding extra 0s at the front to either x or y if one has more digits before the decimal point.\n\n3. Now, we should have x and y have equal lengths in their nums vectors.\n\n4. We reverse the nums vectors for both x and y and compare the digits starting from the first digit.\n\n5. By comparing the first digit, if x's first digit is greater, return TRUE, if y's is, then return FALSE.\n\n6. If the digits are the same, then we move on to the next digit and do the comparison again.\n\n**Test Cases:**\n```{r}\n\nx <- pqnumber(1,5,3,1:9) # 9876.54321\ny <- pqnumber(1,2,0,c(4,1,3)) # 3.14\nz <- pqnumber(-1,1,5,rep(3,7)) # -333333.3\nw <- pqnumber(-1,6,3,c(2,1,1,2,4,5,3,8,7,7)) # -7783.542112\n\nabs_gtr(x, y) # expected value: TRUE\nabs_gtr(y, x) # expected value: FALSE\nabs_gtr(x, z) # expected value: FALSE\nabs_gtr(w, x) # expected value: FALSE\n```\n\n#### **`add()`**\n\n**Algorithm:**\n\n1. We first initialize a vector z of length max_p + max_q + 1, which represents the maximum number of digits we can possibly obtain by adding two numbers (considering the case of a carry-over).\n\n2. Now, we split it into casework: first case is when x and y have equal signs, second case is when x and y have unequal signs.\n\n3. When the signs are equal, we simply add the two by aligning positions, then call the carry-over helper function to carry over digits if necessary.\n\n4. When the signs are unequal, we first check which number has a greater absolute magnitude.\n\n5. Then, we grab the sign of the number that has a greater absolute magnitude and we change the signs for the nums vector of the other number.\n\n6. We proceed with the same addition process (as in step 3) and then use the carry-over function.\n\n7. We return the sum as a pqnumber object.\n\n**Test Cases:**\n```{r}\nx <- pqnumber(-1,3,4,1:8) # -87654.321\ny <- pqnumber(-1,2,0,c(4,1,3)) # -3.14\nz <- pqnumber(1,1,3,c(7,3,2,5,6)) # 6523.7\nw <- pqnumber(1,3,5,c(3,1,2,4,5,3,8,7,7)) # 778354.213\n\nadd(x,z) # expected value: -81130.621 in pqnumber form\nadd(z,w) # expected value: 784877.913 in pqnumber form\nadd(z,y) # expected value: 6520.56 in pqnumber form\n\n```\n\n#### **`subtract()`**\n\n**Algorithm:**\n\n1. We simply change the sign of y by multiplying its sign by -1.\n\n2. Then, we do add(x,y) since x + (-y) is equal to x - y (or subtract(x,y)).\n\n**Test Cases:**\n```{r}\nx <- pqnumber(-1,3,4,1:8) # -87654.321\ny <- pqnumber(-1,2,0,c(4,1,3)) # -3.14\nz <- pqnumber(1,1,3,c(7,3,2,5,6)) # 6523.7\nw <- pqnumber(1,3,5,c(3,1,2,4,5,3,8,7,7)) # 778354.213\n\nsubtract(x,z) # expected value: -94178.021 in pqnumber form\nsubtract(w,x) # expected value: 866008.534 in pqnumber form\nsubtract(y,z) # expected value: -6526.84 in pqnumber form\n\n```\n\n## c) Multiplication\n\n#### **`multiply()`**\n\n**Algorithm:**\n\n1. We first initialize a vector z of length x\\$p + x\\$q + y\\$p + y\\$q + 1, which represents the maximum number of digits we can possibly obtain by multiplying two numbers (considering the case of a carry-over).\n\n2. Now, we iterate through each element of nums of y and we multiply it with the entire nums vector of x and place it in the appropriate indices of z.\n\n3. We use carry-over function to clear any carries.\n\n4. We determine the sign of the product by multiplying the sign of x with the sign of y.\n\n5. We return the product as a pqnumber object.\n\n**Test Cases:**\n```{r}\n\nx <- pqnumber(-1,1,1,1:3) # -32.1\ny <- pqnumber(-1,2,0,c(4,1,3)) # -3.14\nz <- pqnumber(1,3,2,c(3,1,9,4,5,7)) # 754.913\n\nmultiply(x,z) # expected value: -24232.7073 in pqnumber form\nmultiply(x,y) # expected value: 100.794 in pqnumber form\nmultiply(y,x) # expected value: 100.794 in pqnumber form\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":"html_document","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"OOP.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","comments":{"giscus":{"repo":"jryu20/quarto"}},"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Objected Oriented Programming in R","author":"Jun Ryu","date":"2023-03-09","categories":["R","OOP"],"image":"https://upload.wikimedia.org/wikipedia/commons/a/a3/Arithmetic_symbols.svg"},"extensions":{"book":{"multiFile":true}}}}}