{"title":"Intro to Data Manipulation","markdown":{"yaml":{"title":"Intro to Data Manipulation","author":"Jun Ryu","date":"2023-02-05","format":{"html":{"toc":true}},"categories":["R","tidyverse"],"output":"html_document"},"headingText":"a) Simulate a Dataset","containsRefs":false,"markdown":"\n\nFor today, we import two powerful packages (`dplyr` and `tidyr`) under [tidyverse](https://tidyverse.tidyverse.org/) that will help us clean and manipulate data easily.\n\n```{r}\nlibrary(dplyr)\nlibrary(tidyr) \n```\n\n---\n\n\nOur first task is to create a dataset that we can work with. We intend to simulate a dataset that resembles a *gradebook*. Specifically, we want the following:\n\n* Each row of the gradebook should contain all measurements for a single student.\n* Each column should contain scores for one assignment.\n* There should be 11 columns (1 for 9-digit student IDs, 5 for homework, 5 for quizzes).\n\nThe simulated *gradebook* should contain the grades for 100 students and scores (out of 100) for 5 homework and 5 quizzes:\n\n```{r}\nset.seed(605574052) # set seed for reproducibility \ngradebook <- data.frame()\n\nfor (i in 1:100) {\n  UID <- round(runif(1, min = 100000000, max = 999999999), 0)\n  assignments <- round(runif(10, min = 0, max = 100), 0)\n  data <- c(UID, assignments)\n  gradebook <- rbind(gradebook, data)\n}\n\ncolnames(gradebook) <- c(\"UID\", \"Homework_1\", \"Homework_2\", \"Homework_3\", \"Homework_4\", \n                         \"Homework_5\", \"Quiz_1\", \"Quiz_2\", \"Quiz_3\", \"Quiz_4\", \"Quiz_5\")\nhead(gradebook)\n```\n\n---\n\n## b) Modify the Dataset\n\nNow, we will modify the dataset to randomly replace 10% of `Homework_4` and `Quiz_4` with `NA`, respectively.\n\n```{r}\nset.seed(605574052)\n\ngradebook[sample(100, 10), \"Homework_4\"] <- NA\ngradebook[sample(100, 10), \"Quiz_4\"] <- NA\n\nsum(is.na(gradebook[\"Homework_4\"])) # should output 10\nsum(is.na(gradebook[\"Quiz_4\"])) # should output 10\n```\n\nWith this, our dataset is all ready to go. In the later parts, we will perform *imputation* on the data using two different approaches. Here, *imputation* is the process of replacing missing values with estimated values. The simplest (far from preferred) method to impute values is to replace missing values with the most typical value, say the mean or the median.\n\n## c) Messy Imputation\n\nIn this part, we will try to **impute** the `NA` values WITHOUT using any of the tools provided by `dplyr` or `tidyr`. \n\nIn order to achieve this, we will write a function `messy_impute()` with at least three arguments:\n\n* **df**:  the gradebook dataframe (note that the number of rows and where `NA` values occur may be different)\n* **center**: a character object indicating the impute function (Mean or Median) with the default as “Mean”\n* **margin**: an integer (1 or 2) indicating the imputation method (if `1`, the function imputes the missing values by row, if `2`, by column. if choosing by column, the function should process homework and quizzes separately)\n\n\n#### **`messy_impute()`**\n\n**Algorithm:**\n\n1. We first determine how to impute based on the measure of center (mean or median).\n\n2. We call the helper function, which first establishes the indices of the `NA` values in the data frame.\n\n3. The helper function determines how to impute based on the margin value (row or column).\n\n4. If we are imputing by row, then we iterate through each `NA` value and impute the missing values.\n\n5. If we are imputing by column, then we iterate through each `NA` value but we check what category (homework or quiz) each `NA` value falls under.\n\n6. Based on which category the `NA` value falls under, we impute by that category separately.\n\n7. We return the imputed data frame.\n\n```{r}\nmessy_impute_data <- function(df, center_fn, margin, ...) {\n  # This helper function essentially sets up the imputation process based on the center method (mean or median) and margin (row or column)\n  # This will throw an error if the margin is any input other than 1 or 2\n  # This will also throw an error if the score does not belong in either the homework or quiz category\n  # Args:\n  # df: the gradebook data frame\n  # center_fn: center function (either mean or margin)\n  # margin: the margin (either row or column)\n  # ...: extra args to pass onto the center_fn\n  # Return:\n  # the imputed data frame\n  \n  index <- which(is.na(df), arr.ind = TRUE)\n  if (margin == 1) {\n    for (i in 1:nrow(index)) {\n      df[index[i,1], index[i,2]] <- center_fn(df[ ,index[i,2]], na.rm = T, ...)\n    }\n  } else if (margin == 2) {\n    for (i in 1:nrow(index)) {\n      if (grepl(\"Homework\", colnames(gradebook)[index[i,2]])) {\n        df[index[i,1], index[i,2]] <- apply(gradebook[index[i,1], grepl(\"Homework\", names(gradebook))], 1, center_fn, na.rm = T, ...)\n      } else if (grepl(\"Quiz\", colnames(gradebook)[index[i,2]])) {\n        df[index[i,1], index[i,2]] <- apply(gradebook[index[i,1], grepl(\"Quiz\", names(gradebook))], 1, center_fn, na.rm = T, ...)\n      } else {\n        stop(\"This score does not belong to either the homework or quiz category.\")\n      }\n    }\n  } else {\n    stop(\"The margin must be either 1 (by row) or 2 (by column).\")\n  }\n  df\n}\n\nmessy_impute <- function(df, center = \"Mean\", margin, ...) {\n  # This function uses the above helper function to actually impute the data frame \n  # This will throw an error if the measure of center is not mean or median\n  # Args:\n  # df: the gradebook data frame\n  # center: center function with default as mean (either mean or margin)\n  # margin: the margin (either row or column)\n  # ...: extra args to pass onto the center_fn in the helper function\n  # Return:\n  # the imputed data frame\n  \n  center <- tolower(center)\n  if (center == \"mean\") {\n    df <- messy_impute_data(df, mean, margin, ...)\n  } else if (center == \"median\") {\n    df <- messy_impute_data(df, median, margin, ...)\n  } else {\n    stop(\"The measure of center must be either 'mean' or 'median'.\")\n  }\n  \n  df\n}\n```\n\n---\n\n## d) Demo 1\n\nLet's demonstrate the above function! We will select two students missing `Homework_4` and two students missing `Quiz_4` from our simulated gradebook and perform imputations.\n\n**Test Cases:**\n```{r}\n\ngradebook[3,] # 1st student missing Quiz_4\ngradebook[4,] # 2nd student missing Quiz_4\ngradebook[8,] # 1st student missing Homework_4\ngradebook[22,] # 2nd student missing Homework_4\n\nmessy_impute(gradebook, \"mean\", 1)[3,] #apply row imputing by mean for 1st student missing Quiz_4; expected imputed value: 48.25556\nmessy_impute(gradebook, \"median\", 2)[4,] #apply column imputing by median for 2nd student missing Quiz_4; expected imputed value: 61\nmessy_impute(gradebook, \"mean\", 2)[8, ] #apply column imputing by mean for 1st student missing Homework_4; expected imputed value: 60.5\nmessy_impute(gradebook, \"mean\", 1, trim = 0.25)[22,] #apply row imputing by mean (with trim) for 2nd student missing Homework_4; expected imputed value: 54.54348\n\n```\n\n---\n\nThe function definitely works as intended, but the code looks quite messy. What happens when we make use of `tidyr` and `dplyr`?\n\n## e) Convert the Data\n\nFirst, we will convert our simulated dataset into a tidy format.\n\n```{r}\ngradebook_tidy <- as_tibble(gradebook) %>% pivot_longer(names(gradebook)[-1], names_to = c(\"Assignment_Type\", \"Assignment_Number\"), values_to = \"Score\", names_sep = \"_\")\n\ngradebook_tidy\n```\n\n---\n\n## f) Tidy Imputation\n\nTo perform tidy imputation, we will write a function called `tidy_impute()`. The trick here is to make use of `group_by()` in order to pull the appropriate data needed for each imputation method. The `tidy_impute()` function should have the same arguments as the `messy_impute()` function. \n\n#### **`tidy_impute()`**\n\n**Algorithm:**\n\n1. We first determine how to impute based on the measure of center (mean or median).\n\n2. We create a center function that reflects the measure of center.\n\n3. We now determine how to impute based on margin (row or column).\n\n4. If imputing by row, we first group by assignment_type and assignment_number.\n\n5. Then, we mutate the Score column of the tidy data using an if_else statement to see where the NA values are.\n\n6. If imputing by column, we group by student IDs and assignment_type, then do step 5 as described above.\n\n7. We return the imputed tidy data.\n\n```{r}\ntidy_impute <- function(tidy_df, center = \"Mean\", margin, ...) {\n  # This function imputes a tidy data\n  # This will throw an error if the measure of center is not mean or median\n  # This will also throw an error if the margin is any input other than 1 or 2\n  # Args:\n  # tidy_df: the tidied gradebook data\n  # center: center function with default as mean (either mean or margin)\n  # margin: the margin (either row or column)\n  # ...: extra args to pass onto the center_fn\n  # Return:\n  # the imputed tidy data\n  \n  center <- tolower(center)\n  if (center == \"mean\") {\n    center_fn <- function(x) mean(x, na.rm = T, ...)\n  } else if (center == \"median\") {\n    center_fn <- function(x) median(x, na.rm = T, ...)\n  } else {\n    stop(\"The measure of center must be either 'mean' or 'median'.\")\n  }\n  \n  if (margin == 1) {\n    tidy_df <- tidy_df %>% group_by(Assignment_Type, Assignment_Number) %>% mutate(Score=if_else(is.na(Score), center_fn(Score), Score))\n  } else if (margin == 2) {\n    tidy_df <- tidy_df %>% group_by(UID, Assignment_Type) %>% mutate(Score=if_else(is.na(Score), center_fn(Score), Score))\n  } else {\n    stop(\"The margin must be either 1 (by row) or 2 (by column).\")\n  }\n  \n  tidy_df\n}\n```\n\n## g) Demo 2\n\nWe use the same cases from d) to demonstrate our new function, `tidy_impute()`.\n\n```{r}\n\ngradebook_tidy[29,] # 1st student missing Quiz_4\ngradebook_tidy[39,] # 2nd student missing Quiz_4\ngradebook_tidy[74,] # 1st student missing Homework_4\ngradebook_tidy[214,] # 2nd student missing Homework_4\n\n#tidy_impute should result in the same numbers as messy_impute\ntidy_impute(gradebook_tidy, \"mean\", 1)[29,] #expected imputed value: 48.25556\ntidy_impute(gradebook_tidy, \"median\", 2)[39,] #expected imputed value: 61\ntidy_impute(gradebook_tidy, \"mean\", 2)[74, ] #expected imputed value: 60.5\ntidy_impute(gradebook_tidy, \"mean\", 1, trim = 0.25)[214,] #expected imputed value: 54.54348\n\n```\n\n---\n\nGreat! The new function also works as intended and is much more concise than `messy_impute()`. With this, we discover the power of using `tidyverse` for any data-related work.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":"html_document","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"tidyr.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","comments":{"giscus":{"repo":"jryu20/quarto"}},"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Intro to Data Manipulation","author":"Jun Ryu","date":"2023-02-05","categories":["R","tidyverse"]},"extensions":{"book":{"multiFile":true}}}}}