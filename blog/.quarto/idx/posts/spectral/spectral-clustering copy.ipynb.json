{"title":"Spectral Clustering. What is it?","markdown":{"yaml":{"title":"Spectral Clustering. What is it?","image":"spectral.png","format":{"html":{"toc":true}},"author":"Jun Ryu","date":"2023-06-21","categories":["python","ML"]},"headingText":"Preface","containsRefs":false,"markdown":"\n\n\n> In this post, we will explore a simple version of the *spectral clustering* algorithm for clustering data points. Spectral clustering is an important tool for identifying meaningful parts of data sets with complex structure. \n\n### Notation\n\nIn all the math below: \n\n- Boldface capital letters like $\\mathbf{A}$ refer to matrices (2d arrays of numbers). \n- Boldface lowercase letters like $\\mathbf{v}$ refer to vectors (1d arrays of numbers). \n- $\\mathbf{A}\\mathbf{B}$ refers to a matrix-matrix product (`A@B`). $\\mathbf{A}\\mathbf{v}$ refers to a matrix-vector product (`A@v`). \n\n## Introduction\n\nTo begin, let's look at an example where we *don't* need spectral clustering. \n\n*Clustering* refers to the task of separating this data set into the two natural \"blobs.\" K-means is a very common way to achieve this task, which has good performance on circular-ish blobs like these: \n\n#### Harder Clustering\n\nThat was all well and good, but what if our data is \"shaped weird\"? \n\nWe can still make out two meaningful clusters in the data, but now they aren't blobs but crescents. As before, the Euclidean coordinates of the data points are contained in the matrix `X`, while the labels of each point are contained in `y`. Now k-means won't work so well, because k-means is, by design, looking for circular clusters. \n\nWhoops! That's not right! \n\nAs we'll see, spectral clustering is able to correctly cluster the two crescents. In the following parts, we will derive and implement spectral clustering.\n\n## Part A\n\nIn this part, we will construct the *similarity matrix* $\\mathbf{A}$. $\\mathbf{A}$ should be a matrix (2d `np.ndarray`) with shape `(n, n)` (recall that `n` is the number of data points). \n\nWhen constructing the similarity matrix, we will use a parameter `epsilon`. Entry `A[i,j]` should be equal to `1` if `X[i]` (the coordinates of data point `i`) is within distance `epsilon` of `X[j]` (the coordinates of data point `j`), and `0` otherwise. \n\n**For this matrix, the diagonal entries `A[i,i]` should all be equal to zero.** We will use `epsilon = 0.4` for now. \n\n## Part B\n\nThe matrix `A` now contains information about which points are near (within distance `epsilon`) which other points. We now pose the task of clustering the data points in `X` as the task of partitioning the rows and columns of `A`. \n\nLet $d_i = \\sum_{j = 1}^n a_{ij}$ be the $i$th row-sum of $\\mathbf{A}$, which is also called the *degree* of $i$. Let $C_0$ and $C_1$ be two clusters of the data points. We assume that every data point is in either $C_0$ or $C_1$. The cluster membership as being specified by `y`. We think of `y[i]` as being the label of point `i`. So, if `y[i] = 1`, then point `i` (and therefore row $i$ of $\\mathbf{A}$) is an element of cluster $C_1$.  \n\nThe *binary norm cut objective* of a matrix $\\mathbf{A}$ is the function \n\n$$N_{\\mathbf{A}}(C_0, C_1)\\equiv \\mathbf{cut}(C_0, C_1)\\left(\\frac{1}{\\mathbf{vol}(C_0)} + \\frac{1}{\\mathbf{vol}(C_1)}\\right)\\;.$$\n\nIn this expression, \n\n* $\\mathbf{cut}(C_0, C_1) \\equiv \\sum_{i \\in C_0, j \\in C_1} a_{ij}$ is the *cut* of the clusters $C_0$ and $C_1$. \n* $\\mathbf{vol}(C_0) \\equiv \\sum_{i \\in C_0}d_i$, where $d_i = \\sum_{j = 1}^n a_{ij}$ is the *degree* of row $i$ (the total number of all other rows related to row $i$ through $A$). The *volume* of cluster $C_0$ is a measure of the size of the cluster.\n\nA pair of clusters $C_0$ and $C_1$ is considered to be a \"good\" partition of the data when $N_{\\mathbf{A}}(C_0, C_1)$ is small. To see why, let's look at each of the two factors in this objective function separately. \n\n\n#### B.1 The Cut Term\n\nFirst, the cut term $\\mathbf{cut}(C_0, C_1)$ is the number of nonzero entries in $\\mathbf{A}$ that relate points in cluster $C_0$ to points in cluster $C_1$. Saying that this term should be small is the same as saying that points in $C_0$ shouldn't usually be very close to points in $C_1$. \n\nHere, we will write a function called `cut(A,y)` to compute the cut term.\n\nNow, we will compute the cut objective for the true clusters `y`. Then, we will generate a random vector of random labels of length `n`, with each label equal to either 0 or 1, and check the cut objective for the random labels. We should get that the cut objective for the true labels is *much* smaller than the cut objective for the random labels. \n\nThis shows that this part of the cut objective indeed favors the true clusters over the random ones. \n\n#### B.2 The Volume Term \n\nNow, the *volume term*. As mentioned above, the *volume* of cluster $C_0$ is a measure of how \"big\" cluster $C_0$ is. If we choose cluster $C_0$ to be small, then $\\mathbf{vol}(C_0)$ will be small and $\\frac{1}{\\mathbf{vol}(C_0)}$ will be large, leading to an undesirable higher objective value. \n\nSynthesizing, the binary normcut objective asks us to find clusters $C_0$ and $C_1$ such that:\n\n1. There are relatively few entries of $\\mathbf{A}$ that join $C_0$ and $C_1$. \n2. Neither $C_0$ and $C_1$ are too small. \n\nWe will write a function called `vols(A,y)` which computes the volumes of $C_0$ and $C_1$, returning them as a tuple. For example, `v0, v1 = vols(A,y)` should result in `v0` holding the volume of cluster `0` and `v1` holding the volume of cluster `1`. Then, we will write a function called `normcut(A,y)` which uses `cut(A,y)` and `vols(A,y)` to compute the binary normalized cut objective of a matrix `A` with clustering vector `y`. \n\nNow, we will compare the `normcut` objective using both the true labels `y` and the fake labels we generated above.\n\nWe notice that the normcut for the true labels is significantly smaller than the normcut for the fake labels.\n\n## Part C\n\nWe have now defined a normalized cut objective which takes small values when the input clusters are (a) joined by relatively few entries in $A$ and (b) not too small. One approach to clustering is to try to find a cluster vector `y` such that `normcut(A,y)` is small. However, this is an NP-hard combinatorial optimization problem, which means that may not be possible to find the best clustering in practical time, even for relatively small data sets. We need a math trick! \n\nHere's the trick: define a new vector $\\mathbf{z} \\in \\mathbb{R}^n$ such that: \n\n$$\nz_i = \n\\begin{cases}\n    \\frac{1}{\\mathbf{vol}(C_0)} &\\quad \\text{if } y_i = 0 \\\\ \n    -\\frac{1}{\\mathbf{vol}(C_1)} &\\quad \\text{if } y_i = 1 \\\\ \n\\end{cases}\n$$\n\n\nNote that the signs of  the elements of $\\mathbf{z}$ contain all the information from $\\mathbf{y}$: if $i$ is in cluster $C_0$, then $y_i = 0$ and $z_i > 0$. \n\nNext, by linear algebra, we can show that \n\n$$\\mathbf{N}_{\\mathbf{A}}(C_0, C_1) = \\frac{\\mathbf{z}^T (\\mathbf{D} - \\mathbf{A})\\mathbf{z}}{\\mathbf{z}^T\\mathbf{D}\\mathbf{z}}\\;,$$\n\nwhere $\\mathbf{D}$ is the diagonal matrix with nonzero entries $d_{ii} = d_i$, and  where $d_i = \\sum_{j = 1}^n a_i$ is the degree (row-sum) from before. \n\nNow, we will achieve three tasks in this part:\n\n1. We will write a function called `transform(A,y)` to compute the appropriate $\\mathbf{z}$ vector given `A` and `y`, using the formula above. \n2. Then, we will check the equation above that relates the matrix product to the normcut objective, by computing each side separately and checking that they are equal. \n3. We will also check the identity $\\mathbf{z}^T\\mathbf{D}\\mathbb{1} = 0$, where $\\mathbb{1}$ is the vector of `n` ones (i.e. `np.ones(n)`). This identity effectively says that $\\mathbf{z}$ should contain roughly as many positive as negative entries.  \n\n::: {.callout-warning}\nThe equation above is exact, but computer arithmetic is not! `np.isclose(a,b)` is a good way to check if `a` is \"close\" to `b`, in the sense that they differ by less than the smallest amount that the computer is (by default) able to quantify. \n:::\n\n## Part D\n\nIn the last part, we saw that the problem of minimizing the normcut objective is mathematically related to the problem of minimizing the function \n\n$$ R_\\mathbf{A}(\\mathbf{z})\\equiv \\frac{\\mathbf{z}^T (\\mathbf{D} - \\mathbf{A})\\mathbf{z}}{\\mathbf{z}^T\\mathbf{D}\\mathbf{z}} $$\n\nsubject to the condition $\\mathbf{z}^T\\mathbf{D}\\mathbb{1} = 0$. It's actually possible to bake this condition into the optimization, by substituting for $\\mathbf{z}$ the orthogonal complement of $\\mathbf{z}$ relative to $\\mathbf{D}\\mathbf{1}$. In the code below, `orth_obj` function is defined, which handles this. \n\nNext, we will use the `minimize` function from `scipy.optimize` to minimize the function `orth_obj` with respect to $\\mathbf{z}$. Note that this computation might take a little while. Explicit optimization can be pretty slow! We will give the minimizing vector a name `z_min`. \n\n::: {.callout-note}\nThere's a cheat going on here! We originally specified that the entries of $\\mathbf{z}$ should take only one of two values (back in Part C), whereas now we're allowing the entries to have *any* value! This means that we are no longer exactly optimizing the normcut objective, but rather an approximation. This cheat is so common that deserves a name: it is called the *continuous relaxation* of the normcut problem. \n:::\n\n## Part E\n\nRecall that, by design, only the sign of `z_min[i]` actually contains information about the cluster label of data point `i`. Thus, we plot the original data, using one color for points such that `z_min[i] < 0` and another color for points such that `z_min[i] >= 0`. \n\nHmm... Something looks off here. Let's fix it!\n\n## Part F\n\nExplicitly optimizing the orthogonal objective is  *way* too slow to be practical. If spectral clustering required that we do this each time, no one would use it. \n\nThe reason that spectral clustering actually matters, and indeed the reason that spectral clustering is called *spectral* clustering, is that we can actually solve the problem from Part E using eigenvalues and eigenvectors of matrices. \n\nRecall that what we would like to do is minimize the function \n\n$$ R_\\mathbf{A}(\\mathbf{z})\\equiv \\frac{\\mathbf{z}^T (\\mathbf{D} - \\mathbf{A})\\mathbf{z}}{\\mathbf{z}^T\\mathbf{D}\\mathbf{z}} $$\n\nwith respect to $\\mathbf{z}$, subject to the condition $\\mathbf{z}^T\\mathbf{D}\\mathbb{1} = 0$. \n\nThe Rayleigh-Ritz Theorem states that the minimizing $\\mathbf{z}$ must be the solution with smallest eigenvalue of the generalized eigenvalue problem \n\n$$ (\\mathbf{D} - \\mathbf{A}) \\mathbf{z} = \\lambda \\mathbf{D}\\mathbf{z}\\;, \\quad \\mathbf{z}^T\\mathbf{D}\\mathbb{1} = 0$$\n\nwhich is equivalent to the standard eigenvalue problem \n\n$$ \\mathbf{D}^{-1}(\\mathbf{D} - \\mathbf{A}) \\mathbf{z} = \\lambda \\mathbf{z}\\;, \\quad \\mathbf{z}^T\\mathbb{1} = 0\\;.$$\n\nWhy is this helpful? Well, $\\mathbb{1}$ is actually the eigenvector with smallest eigenvalue of the matrix $\\mathbf{D}^{-1}(\\mathbf{D} - \\mathbf{A})$. \n\n> So, the vector $\\mathbf{z}$ that we want must be the eigenvector with  the *second*-smallest eigenvalue. \n\nSo, we will construct the matrix $\\mathbf{L} = \\mathbf{D}^{-1}(\\mathbf{D} - \\mathbf{A})$, which is often called the (normalized) *Laplacian* matrix of the similarity matrix $\\mathbf{A}$. Next, we will find the eigenvector corresponding to its second-smallest eigenvalue, and call it `z_eig`. Then, we will plot the data again, using the sign of `z_eig` as the color.\n\nThis looks a lot better!\n\n## Part G\n\nWe will synthesize our results from all the previous parts. In particular, we will write a function called `spectral_clustering(X, epsilon)` which takes in the input data `X` (in the same format as Part A) and the distance threshold `epsilon` and performs spectral clustering, returning an array of binary labels indicating whether data point `i` is in group `0` or group `1`. We will demonstrate our function using the supplied data from the beginning of the problem.  \n\n#### Outline\n\nGiven data, we need to: \n\n1. Construct the similarity matrix. \n2. Construct the Laplacian matrix. \n3. Compute the eigenvector with second-smallest eigenvalue of the Laplacian matrix. \n4. Return labels based on this eigenvector. \n\n## Part H\n\nLet's run one more experiment using our function, by generating a different data set using `make_moons`. What happens when we increase the `noise`? Will spectral clustering still find the two half-moon clusters? For these experiments, we might find it useful to increase `n` to `1000` or so -- we can do this now, because of our fast algorithm!\n\n## Part I\n\nNow let's try our spectral clustering function on another data set -- the bull's eye! \n\nThere are two concentric circles. As before k-means will not do well here at all. \n\nCan our function successfully separate the two circles? Some experimentation here with the value of `epsilon` is likely to be required.\n\nThrough experimentation, we find that an `epsilon` value of `0.4` is able to accurately cluster this data!\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"spectral-clustering copy.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","comments":{"giscus":{"repo":"jryu20/quarto"}},"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Spectral Clustering. What is it?","image":"spectral.png","author":"Jun Ryu","date":"2023-06-21","categories":["python","ML"]},"extensions":{"book":{"multiFile":true}}}}}