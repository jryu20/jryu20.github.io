{
  "hash": "859c3e093b13211f9a29149c401d5e8d",
  "result": {
    "markdown": "---\ntitle: \"Intro to Data Manipulation\"\nauthor: \"Jun Ryu\"\ndate: \"2023-02-05\"\nformat:\n  html:\n    toc: true\ncategories: [R, tidyverse]\noutput: html_document\n---\n\n\nFor today, we import two powerful packages (`dplyr` and `tidyr`) under [tidyverse](https://tidyverse.tidyverse.org/) that will help us clean and manipulate data easily.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyr) \n```\n:::\n\n\n---\n\n## a) Simulate a Dataset\n\nOur first task is to create a dataset that we can work with. We intend to simulate a dataset that resembles a *gradebook*. Specifically, we want the following:\n\n* Each row of the gradebook should contain all measurements for a single student.\n* Each column should contain scores for one assignment.\n* There should be 11 columns (1 for 9-digit student IDs, 5 for homework, 5 for quizzes).\n\nThe simulated *gradebook* should contain the grades for 100 students and scores (out of 100) for 5 homework and 5 quizzes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(605574052) # set seed for reproducibility \ngradebook <- data.frame()\n\nfor (i in 1:100) {\n  UID <- round(runif(1, min = 100000000, max = 999999999), 0)\n  assignments <- round(runif(10, min = 0, max = 100), 0)\n  data <- c(UID, assignments)\n  gradebook <- rbind(gradebook, data)\n}\n\ncolnames(gradebook) <- c(\"UID\", \"Homework_1\", \"Homework_2\", \"Homework_3\", \"Homework_4\", \n                         \"Homework_5\", \"Quiz_1\", \"Quiz_2\", \"Quiz_3\", \"Quiz_4\", \"Quiz_5\")\nhead(gradebook)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n1 532521854         45         17         75         22         13     80\n2 486614393         20         50         82         78         41     53\n3 576992987         53         54         85         52         29     35\n4 143843463         33          2          6         39         39     49\n5 773280766         99         25         52         51         17     42\n6 486851405         58         38         76         49         86     39\n  Quiz_2 Quiz_3 Quiz_4 Quiz_5\n1     87     83     82     11\n2     10     55     73     42\n3     74     28     27     46\n4     55     97     84     67\n5     66     37    100     10\n6      7     80      2     16\n```\n:::\n:::\n\n\n---\n\n## b) Modify the Dataset\n\nNow, we will modify the dataset to randomly replace 10% of `Homework_4` and `Quiz_4` with `NA`, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(605574052)\n\ngradebook[sample(100, 10), \"Homework_4\"] <- NA\ngradebook[sample(100, 10), \"Quiz_4\"] <- NA\n\nsum(is.na(gradebook[\"Homework_4\"])) # should output 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nsum(is.na(gradebook[\"Quiz_4\"])) # should output 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nWith this, our dataset is all ready to go. In the later parts, we will perform *imputation* on the data using two different approaches. Here, *imputation* is the process of replacing missing values with estimated values. The simplest (far from preferred) method to impute values is to replace missing values with the most typical value, say the mean or the median.\n\n## c) Messy Imputation\n\nIn this part, we will try to **impute** the `NA` values WITHOUT using any of the tools provided by `dplyr` or `tidyr`. \n\nIn order to achieve this, we will write a function `messy_impute()` with at least three arguments:\n\n* **df**:  the gradebook dataframe (note that the number of rows and where `NA` values occur may be different)\n* **center**: a character object indicating the impute function (Mean or Median) with the default as “Mean”\n* **margin**: an integer (1 or 2) indicating the imputation method (if `1`, the function imputes the missing values by row, if `2`, by column. if choosing by column, the function should process homework and quizzes separately)\n\n\n#### **`messy_impute()`**\n\n**Algorithm:**\n\n1. We first determine how to impute based on the measure of center (mean or median).\n\n2. We call the helper function, which first establishes the indices of the `NA` values in the data frame.\n\n3. The helper function determines how to impute based on the margin value (row or column).\n\n4. If we are imputing by row, then we iterate through each `NA` value and impute the missing values.\n\n5. If we are imputing by column, then we iterate through each `NA` value but we check what category (homework or quiz) each `NA` value falls under.\n\n6. Based on which category the `NA` value falls under, we impute by that category separately.\n\n7. We return the imputed data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmessy_impute_data <- function(df, center_fn, margin, ...) {\n  # This helper function essentially sets up the imputation process based on the center method (mean or median) and margin (row or column)\n  # This will throw an error if the margin is any input other than 1 or 2\n  # This will also throw an error if the score does not belong in either the homework or quiz category\n  # Args:\n  # df: the gradebook data frame\n  # center_fn: center function (either mean or margin)\n  # margin: the margin (either row or column)\n  # ...: extra args to pass onto the center_fn\n  # Return:\n  # the imputed data frame\n  \n  index <- which(is.na(df), arr.ind = TRUE)\n  if (margin == 1) {\n    for (i in 1:nrow(index)) {\n      df[index[i,1], index[i,2]] <- center_fn(df[ ,index[i,2]], na.rm = T, ...)\n    }\n  } else if (margin == 2) {\n    for (i in 1:nrow(index)) {\n      if (grepl(\"Homework\", colnames(gradebook)[index[i,2]])) {\n        df[index[i,1], index[i,2]] <- apply(gradebook[index[i,1], grepl(\"Homework\", names(gradebook))], 1, center_fn, na.rm = T, ...)\n      } else if (grepl(\"Quiz\", colnames(gradebook)[index[i,2]])) {\n        df[index[i,1], index[i,2]] <- apply(gradebook[index[i,1], grepl(\"Quiz\", names(gradebook))], 1, center_fn, na.rm = T, ...)\n      } else {\n        stop(\"This score does not belong to either the homework or quiz category.\")\n      }\n    }\n  } else {\n    stop(\"The margin must be either 1 (by row) or 2 (by column).\")\n  }\n  df\n}\n\nmessy_impute <- function(df, center = \"Mean\", margin, ...) {\n  # This function uses the above helper function to actually impute the data frame \n  # This will throw an error if the measure of center is not mean or median\n  # Args:\n  # df: the gradebook data frame\n  # center: center function with default as mean (either mean or margin)\n  # margin: the margin (either row or column)\n  # ...: extra args to pass onto the center_fn in the helper function\n  # Return:\n  # the imputed data frame\n  \n  center <- tolower(center)\n  if (center == \"mean\") {\n    df <- messy_impute_data(df, mean, margin, ...)\n  } else if (center == \"median\") {\n    df <- messy_impute_data(df, median, margin, ...)\n  } else {\n    stop(\"The measure of center must be either 'mean' or 'median'.\")\n  }\n  \n  df\n}\n```\n:::\n\n\n---\n\n## d) Demo 1\n\nLet's demonstrate the above function! We will select two students missing `Homework_4` and two students missing `Quiz_4` from our simulated gradebook and perform imputations.\n\n**Test Cases:**\n\n::: {.cell}\n\n```{.r .cell-code}\ngradebook[3,] # 1st student missing Quiz_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n3 576992987         53         54         85         52         29     35\n  Quiz_2 Quiz_3 Quiz_4 Quiz_5\n3     74     28     NA     46\n```\n:::\n\n```{.r .cell-code}\ngradebook[4,] # 2nd student missing Quiz_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n4 143843463         33          2          6         39         39     49\n  Quiz_2 Quiz_3 Quiz_4 Quiz_5\n4     55     97     NA     67\n```\n:::\n\n```{.r .cell-code}\ngradebook[8,] # 1st student missing Homework_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n8 473921063         84         82         23         NA         53     63\n  Quiz_2 Quiz_3 Quiz_4 Quiz_5\n8     99     10     68     88\n```\n:::\n\n```{.r .cell-code}\ngradebook[22,] # 2nd student missing Homework_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n22 642770743         73         19         41         NA         15     89\n   Quiz_2 Quiz_3 Quiz_4 Quiz_5\n22     52     63     62     57\n```\n:::\n\n```{.r .cell-code}\nmessy_impute(gradebook, \"mean\", 1)[3,] #apply row imputing by mean for 1st student missing Quiz_4; expected imputed value: 48.25556\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n3 576992987         53         54         85         52         29     35\n  Quiz_2 Quiz_3   Quiz_4 Quiz_5\n3     74     28 48.25556     46\n```\n:::\n\n```{.r .cell-code}\nmessy_impute(gradebook, \"median\", 2)[4,] #apply column imputing by median for 2nd student missing Quiz_4; expected imputed value: 61\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n4 143843463         33          2          6         39         39     49\n  Quiz_2 Quiz_3 Quiz_4 Quiz_5\n4     55     97     61     67\n```\n:::\n\n```{.r .cell-code}\nmessy_impute(gradebook, \"mean\", 2)[8, ] #apply column imputing by mean for 1st student missing Homework_4; expected imputed value: 60.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n8 473921063         84         82         23       60.5         53     63\n  Quiz_2 Quiz_3 Quiz_4 Quiz_5\n8     99     10     68     88\n```\n:::\n\n```{.r .cell-code}\nmessy_impute(gradebook, \"mean\", 1, trim = 0.25)[22,] #apply row imputing by mean (with trim) for 2nd student missing Homework_4; expected imputed value: 54.54348\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         UID Homework_1 Homework_2 Homework_3 Homework_4 Homework_5 Quiz_1\n22 642770743         73         19         41   54.54348         15     89\n   Quiz_2 Quiz_3 Quiz_4 Quiz_5\n22     52     63     62     57\n```\n:::\n:::\n\n\n---\n\nThe function definitely works as intended, but the code looks quite messy. What happens when we make use of `tidyr` and `dplyr`?\n\n## e) Convert the Data\n\nFirst, we will convert our simulated dataset into a tidy format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngradebook_tidy <- as_tibble(gradebook) %>% pivot_longer(names(gradebook)[-1], names_to = c(\"Assignment_Type\", \"Assignment_Number\"), values_to = \"Score\", names_sep = \"_\")\n\ngradebook_tidy\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000 × 4\n         UID Assignment_Type Assignment_Number Score\n       <dbl> <chr>           <chr>             <dbl>\n 1 532521854 Homework        1                    45\n 2 532521854 Homework        2                    17\n 3 532521854 Homework        3                    75\n 4 532521854 Homework        4                    22\n 5 532521854 Homework        5                    13\n 6 532521854 Quiz            1                    80\n 7 532521854 Quiz            2                    87\n 8 532521854 Quiz            3                    83\n 9 532521854 Quiz            4                    82\n10 532521854 Quiz            5                    11\n# … with 990 more rows\n```\n:::\n:::\n\n\n---\n\n## f) Tidy Imputation\n\nTo perform tidy imputation, we will write a function called `tidy_impute()`. The trick here is to make use of `group_by()` in order to pull the appropriate data needed for each imputation method. The `tidy_impute()` function should have the same arguments as the `messy_impute()` function. \n\n#### **`tidy_impute()`**\n\n**Algorithm:**\n\n1. We first determine how to impute based on the measure of center (mean or median).\n\n2. We create a center function that reflects the measure of center.\n\n3. We now determine how to impute based on margin (row or column).\n\n4. If imputing by row, we first group by assignment_type and assignment_number.\n\n5. Then, we mutate the Score column of the tidy data using an if_else statement to see where the NA values are.\n\n6. If imputing by column, we group by student IDs and assignment_type, then do step 5 as described above.\n\n7. We return the imputed tidy data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_impute <- function(tidy_df, center = \"Mean\", margin, ...) {\n  # This function imputes a tidy data\n  # This will throw an error if the measure of center is not mean or median\n  # This will also throw an error if the margin is any input other than 1 or 2\n  # Args:\n  # tidy_df: the tidied gradebook data\n  # center: center function with default as mean (either mean or margin)\n  # margin: the margin (either row or column)\n  # ...: extra args to pass onto the center_fn\n  # Return:\n  # the imputed tidy data\n  \n  center <- tolower(center)\n  if (center == \"mean\") {\n    center_fn <- function(x) mean(x, na.rm = T, ...)\n  } else if (center == \"median\") {\n    center_fn <- function(x) median(x, na.rm = T, ...)\n  } else {\n    stop(\"The measure of center must be either 'mean' or 'median'.\")\n  }\n  \n  if (margin == 1) {\n    tidy_df <- tidy_df %>% group_by(Assignment_Type, Assignment_Number) %>% mutate(Score=if_else(is.na(Score), center_fn(Score), Score))\n  } else if (margin == 2) {\n    tidy_df <- tidy_df %>% group_by(UID, Assignment_Type) %>% mutate(Score=if_else(is.na(Score), center_fn(Score), Score))\n  } else {\n    stop(\"The margin must be either 1 (by row) or 2 (by column).\")\n  }\n  \n  tidy_df\n}\n```\n:::\n\n\n## g) Demo 2\n\nWe use the same cases from d) to demonstrate our new function, `tidy_impute()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngradebook_tidy[29,] # 1st student missing Quiz_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 576992987 Quiz            4                    NA\n```\n:::\n\n```{.r .cell-code}\ngradebook_tidy[39,] # 2nd student missing Quiz_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 143843463 Quiz            4                    NA\n```\n:::\n\n```{.r .cell-code}\ngradebook_tidy[74,] # 1st student missing Homework_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 473921063 Homework        4                    NA\n```\n:::\n\n```{.r .cell-code}\ngradebook_tidy[214,] # 2nd student missing Homework_4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 642770743 Homework        4                    NA\n```\n:::\n\n```{.r .cell-code}\n#tidy_impute should result in the same numbers as messy_impute\ntidy_impute(gradebook_tidy, \"mean\", 1)[29,] #expected imputed value: 48.25556\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n# Groups:   Assignment_Type, Assignment_Number [1]\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 576992987 Quiz            4                  48.3\n```\n:::\n\n```{.r .cell-code}\ntidy_impute(gradebook_tidy, \"median\", 2)[39,] #expected imputed value: 61\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n# Groups:   UID, Assignment_Type [1]\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 143843463 Quiz            4                    61\n```\n:::\n\n```{.r .cell-code}\ntidy_impute(gradebook_tidy, \"mean\", 2)[74, ] #expected imputed value: 60.5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n# Groups:   UID, Assignment_Type [1]\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 473921063 Homework        4                  60.5\n```\n:::\n\n```{.r .cell-code}\ntidy_impute(gradebook_tidy, \"mean\", 1, trim = 0.25)[214,] #expected imputed value: 54.54348\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n# Groups:   Assignment_Type, Assignment_Number [1]\n        UID Assignment_Type Assignment_Number Score\n      <dbl> <chr>           <chr>             <dbl>\n1 642770743 Homework        4                  54.5\n```\n:::\n:::\n\n\n---\n\nGreat! The new function also works as intended and is much more concise than `messy_impute()`. With this, we discover the power of using `tidyverse` for any data-related work.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}