{"title":"Objected Oriented Programming in R","markdown":{"yaml":{"title":"Objected Oriented Programming in R","author":"Jun Ryu","date":"2023-03-09","format":{"html":{"toc":true}},"categories":["R","OOP"],"image":"https://upload.wikimedia.org/wikipedia/commons/b/b8/Lots_of_math_symbols_and_numbers.svg","output":"html_document"},"headingText":"a) Basics","containsRefs":false,"markdown":"\n\n> We define a new object class `pqnumber` to handle computations with large floating point numbers. \n\nA `pqnumber` object should be able to store large numbers and will be defined by the following four components:\n\n1. `sign`: $1$ if positive, $-1$ if negative\n2. `p`: number of digits after the decimal point\n3. `q`: (number of digits before the decimal point $-$ $1$)\n4. `nums`: vector of $p + q + 1$ integers between $0$ and $9$, \n\nFor example, we can use the following object $x$ to keep the number $87654.321$:\n\n```r\nx <- structure(list(sign = 1, p = 3, q = 4, nums = 1:8), class = \"pqnumber\")\n``` \n\n\nTo begin, we must start by defining the following five functions:\n\n* `pqnumber(sign, p, q, nums)`: **constructor** function (returns a `pqnumber` object)\n* `is_pqnumber(x)`: **predicate** function (returns `TRUE` if the input is a `pqnumber` object, `FALSE` otherwise)\n* `print(x, DEC)`: **print** function (prints the components of the `pqnumber` object if `DEC` is `FALSE`, prints the decimal value otherwise)\n* `as_pqnumber(x, p, q)`: generic **coercion** function from `numeric` to `pqnumber`\n* `as_numeric(x)`: generic **coercion** function from `pqnumber` to `numeric`\n\nTo see how these functions are defined, click on the following:\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the Code\"\n\npqnumber <- function(sign, p, q, nums) {\n  # This function is the constructor function for a pqnumber\n  # This will throw an error if:\n  # 1) the sign argument is not the integer 1 or -1\n  # 2) the p argument is not a whole number\n  # 3) the q argument is not a whole number\n  # 4) the length of the nums argument is not equal to p+q+1\n  # 5) the entries in the nums vector are not numbers 0-9\n  # Args:\n  # sign: denotes the sign of the number\n  # p: denotes how many digits are after the decimal point\n  # q: denotes how many digits are before the units digit\n  # nums: a numeric vector we use to construct the pqnumber\n  # Return:\n  # a pqnumber object\n  \n  if (abs(sign) != 1) {\n    stop(\"The sign should be either 1 or -1.\")\n  }\n  if (p %% 1 != 0 | q %% 1 != 0 | p < 0 | q < 0) {\n    stop(\"p and q values must be whole numbers.\")\n  }\n  if (length(nums) != p + q + 1) {\n    stop(\"The length of nums must equal p+q+1.\")\n  }\n  for (i in length(nums)) {\n    if (!(nums[i] %in% 0:9)) {\n      stop(\"The indices of nums must be an integer between 0 and 9.\")\n    } \n  }\n  \n  structure(list(sign = as.integer(sign), p = as.integer(p), q = as.integer(q), nums = as.integer(nums)), class = 'pqnumber')\n}\n\nis_pqnumber <- function(x) {\n  # This function is the predicate function for a pqnumber\n  # Args:\n  # x: any input\n  # Return:\n  # a logical value checking whether the input is a pqnumber object or not\n  any(class(x) == 'pqnumber')\n}\n\nprint.pqnumber <- function(x, DEC = FALSE) {\n  # This function is the print function for a pqnumber\n  # Args:\n  # x: a pqnumber\n  # DEC: default set to FALSE, but if set to TRUE, will return the decimal form\n  # Return:\n  # either the decimal form or the object form (depends on the DEC input)\n  if (DEC) {\n    print_str <- paste0(substr(paste(rev(x$nums), collapse = ''), 1, x$q+1), '.', paste0(substr(paste(rev(x$nums), collapse = ''), x$q+2, length(x$nums))))\n    \n    if (x$sign == -1) {\n      print_str <- paste0('-', print_str)\n    }\n  } else {\n    print_str <- paste0('sign = ', x$sign, '\\np = ', x$p, '\\nq = ', x$q, '\\nnums = ', paste(x$nums, collapse = ' '))\n  }\n  cat(paste0(print_str, '\\n'))\n}\n\nas_pqnumber <- function(x, p, q) {\n  # This function is the generic coercion function for a numeric value into a pqnumber\n  # Args:\n  # x: a numeric value\n  # p: denotes how many digits are after the decimal point\n  # q: denotes how many digits are before the units digit\n  UseMethod('as_pqnumber')\n}\n\nas_pqnumber.numeric <- function(x, p, q) {\n  # This function is the coercion method for the above generic function\n  # Args:\n  # x: a numeric value\n  # p: denotes how many digits are after the decimal point\n  # q: denotes how many digits are before the units digit\n  # Return:\n  # a pqnumber object that satisfies the given inputs\n  nums <- (abs(x) * 10^seq(p, -q)) %% 10 %/% 1\n  sgn <- if(x == 0) 1 else base::sign(x)\n  pqnumber(sgn, p, q, nums)\n}\n\nas_numeric <- function(x) {\n  # This function is the generic coercion function for a pqnumber into a numeric value\n  # Args:\n  # x: a pqnumber\n  UseMethod('as_numeric')\n}\n\nas_numeric.pqnumber <- function(x) {\n  # This function is the coercion method for the above generic function\n  # Args:\n  # x: a pqnumber\n  # Return:\n  # a numeric value that matches the pqnumber input\n  if (x$sign == 1) {\n    numeric <- as.numeric(paste(rev(x$nums), collapse = '')) / 10^(x$p)\n  } else {\n    numeric <- -1*(as.numeric(paste(rev(x$nums), collapse = '')) / 10^(x$p))\n  }\n  numeric\n}\n```\n\n---\n\nThe following are tests to make sure our five functions work as intended:\n\n**Test Cases:**\n\n```{r}\nx <- pqnumber(1, 3, 4, 1:8)\nx\ny <- pqnumber(1, 6, 0, c(3,9,5,1,4,1,3))\ny\nz <- pqnumber(-1, 5, 1, c(2,8,2,8,1,7,2))\nz\n\nis_pqnumber(x) # expected value: TRUE\nis_pqnumber(y) # expected value: TRUE\nis_pqnumber(z) # expected value: TRUE\nis_pqnumber(1230) # expected value: FALSE\n\nprint(x) # expect a pqnumber object (sign = 1, p = 3, q = 4, nums = 1:8)\nprint(y, DEC = T) # expected value: 3.141593\nprint(z, DEC = T) # expected value: -27.18282\n\nas_pqnumber(3.14, 3, 4) # expect a pqnumber object (sign = 1, p = 3, q = 4, nums = c(0,4,1,3,0,0,0,0))\nas_pqnumber(-153.2772, 4, 2) # # expect a pqnumber object (sign = -1, p = 4, q = 2, nums = c(2,7,7,2,3,5,1))\n\nas_numeric(x) # expected value: 87654.321 but might lose precision (\"numeric\" has a default printing of 7 digits)\nas_numeric(pqnumber(-1, 3, 6, rep(1,10))) # expected value: -1111111.111 but might lose precision\n```\n\n---\n\nGreat! All our outputs look correct. Now, the real question is: how can we define basic arithmetic functions for these `pqnumber` objects?\n\n## b) Addition and Subtraction\n\nOur end goal in this section is to come up with two functions: `add(x,y)` and `subtract(x,y)` for $2$ `pqnumber` objects `x` and `y`. To do this, let's write two helper functions:\n\n#### 1. **`carry_over()`** \n\n**Algorithm:**\n\n1. We iterate through each element of a numeric vector.\n\n2. We keep the remainder (when divided by $10$) in its element spot.\n\n3. We locate the existence of a carry by using `%/%` and seeing if it is not equal to $0$.\n\n4. If it's not equal to $0$, we push the carry value onto the next element.\n\n5. We add the carried value to the next element and repeat the process from step 2.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the Code\"\n\ncarry_over <- function(z) {\n  # This helper function is the carry over function that takes care of moving digits when it needs to be moved over to the next index\n  # Args:\n  # z: a numeric vector\n  # Return:\n  # a modified vector of z that has the carry over process completed\n  n <- length(z)\n  carry <- 0\n  for (i in 1:n) {\n    zi <- z[i] + carry\n    z[i] <- zi %% 10\n    carry <- zi %/% 10\n  }\n  \n  if (carry != 0) {\n    z[n+1] <- carry\n  }\n  z\n}\n```\n\n**Test Cases:**\n```{r}\nx <- c(13,4,5)\ncarry_over(x) # expected value: c(3,5,5)\n\ny <- c(31,52,9) \ncarry_over(y) # expected value: c(1,5,4,1)\n\n```\n\n---\n\n#### 2. **`abs_gtr()`**\n\n**Algorithm:**\n\n1. First, we appropriately pad both numbers by adding extra $0$s at the end to either $x$ or $y$ if one has more digits after the decimal point.\n\n2. We do a similar padding by adding extra $0$s at the front to either $x$ or $y$ if one has more digits before the decimal point.\n\n3. Now, we should have $x$ and $y$ have equal lengths in their `nums` vectors.\n\n4. We reverse the `nums` vectors for both $x$ and $y$ and compare the digits starting from the first digit.\n\n5. By comparing the first digit, if $x$'s first digit is greater, return `TRUE`, if $y$'s is, then return `FALSE`.\n\n6. If the digits are the same, then we move on to the next digit and do the comparison again.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the Code\"\n\nabs_gtr <- function(x, y) {\n  # This helper function compares the absolute magnitudes of two pqnumbers\n  # Args:\n  # x: a pqnumber\n  # y: a pqnumber\n  # Return:\n  # TRUE is x has a greater absolute magnitude than y, FALSE if otherwise\n  if (x$p > y$p) {\n    y <- pqnumber(y$sign, x$p, y$q, c(rep(0, x$p-y$p), y$nums))\n  } else {\n    x <- pqnumber(x$sign, y$p, x$q, c(rep(0, y$p-x$p), x$nums))\n  }\n  \n  if (x$q > y$q) {\n    y <- pqnumber(y$sign, y$p, x$q, c(y$nums, rep(0, x$q-y$q)))\n  } else {\n    x <- pqnumber(x$sign, x$p, y$q, c(x$nums, rep(0, y$q-x$q)))\n  }\n  \n  x_rev <- rev(x$nums)\n  y_rev <- rev(y$nums)\n  gtr <- character(1)\n  \n  for (i in 1:length(x$nums)) {\n    if (y_rev[i] > x_rev[i]) {\n      gtr <- F\n      break\n    } else if (x_rev[i] > y_rev[i]) {\n      gtr <- T\n      break\n    } else {\n      next\n    }\n  }\n  \n  gtr\n}\n```\n\n**Test Cases:**\n```{r}\n\nx <- pqnumber(1,5,3,1:9) # 9876.54321\ny <- pqnumber(1,2,0,c(4,1,3)) # 3.14\nz <- pqnumber(-1,1,5,rep(3,7)) # -333333.3\nw <- pqnumber(-1,6,3,c(2,1,1,2,4,5,3,8,7,7)) # -7783.542112\n\nabs_gtr(x, y) # expected value: TRUE\nabs_gtr(y, x) # expected value: FALSE\nabs_gtr(x, z) # expected value: FALSE\nabs_gtr(w, x) # expected value: FALSE\n```\n\n---\n\nWith the above helper functions, we are now ready to write the two main functions:\n\n#### **`add()`**\n\n**Algorithm:**\n\n1. We first initialize a vector $z$ of length $\\text{max\\_p} + \\text{max\\_q} + 1$, which represents the maximum number of digits we can possibly obtain by adding two numbers (considering the case of a carry-over).\n\n2. Now, we split it into casework: first case is when $x$ and $y$ have equal signs, second case is when $x$ and $y$ have unequal signs.\n\n3. When the signs are equal, we simply add the two by aligning positions, then call the carry-over helper function to carry over digits if necessary.\n\n4. When the signs are unequal, we first check which number has a greater absolute magnitude.\n\n5. Then, we grab the sign of the number that has a greater absolute magnitude and we change the signs for the `nums` vector of the other number.\n\n6. We proceed with the same addition process (as in step 3) and then use the carry-over function.\n\n7. We return the sum as a `pqnumber` object.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the Code\"\n\nadd <- function(x, y) {\n  # This function adds two pqnumbers\n  # Args:\n  # x: a pqnumber\n  # y: a pqnumber\n  # Return:\n  # the sum of x and y, returned in a pqnumber format\n  max_p <- max(x$p, y$p)\n  max_q <- max(x$q, y$q)\n  n <- max_p + max_q + 1\n  \n  z <- rep(0L, n)\n  if (x$sign == y$sign) {\n    x_vals <- x$nums\n    y_vals <- y$nums\n    sgn <- x$sign\n    \n  } else {\n    if(abs_gtr(x,y)) {\n      x_vals <- x$nums\n      y_vals <- -y$nums\n      sgn <- x$sign\n      \n    } else {\n      x_vals <- -x$nums\n      y_vals <- y$nums\n      sgn <- y$sign\n    }\n    \n  }\n  \n  z[(1+max_p-x$p):(1+max_p+x$q)] <- x_vals\n  z[(1+max_p-y$p):(1+max_p+y$q)] <- z[(1+max_p-y$p):(1+max_p+y$q)] + y_vals\n  \n  z <- carry_over(z)\n  \n  digit_offset <- length(z) - n\n  pqnumber(sgn, max_p, max_q + digit_offset, z)\n}\n``` \n\n**Test Cases:**\n```{r}\nx <- pqnumber(-1,3,4,1:8) # -87654.321\ny <- pqnumber(-1,2,0,c(4,1,3)) # -3.14\nz <- pqnumber(1,1,3,c(7,3,2,5,6)) # 6523.7\nw <- pqnumber(1,3,5,c(3,1,2,4,5,3,8,7,7)) # 778354.213\n\nadd(x,z) # expected value: -81130.621 in pqnumber form\nadd(z,w) # expected value: 784877.913 in pqnumber form\nadd(z,y) # expected value: 6520.56 in pqnumber form\n\n```\n\n---\n\n#### **`subtract()`**\n\n**Algorithm:**\n\n1. We simply change the sign of $y$ by multiplying its sign by $-1$.\n\n2. Then, we do `add(x,y)` since $x + (-y)$ is equal to $x - y$ (or `subtract(x,y)`).\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the Code\"\n\nsubtract <- function(x, y) {\n  # This function subtracts one pqnumber from the other\n  # Args:\n  # x: a pqnumber\n  # y: a pqnumber\n  # Return:\n  # the difference of x and y, returned in a pqnumber format\n  y$sign <- y$sign * -1\n  add(x, y)\n}\n``` \n\n**Test Cases:**\n```{r}\nx <- pqnumber(-1,3,4,1:8) # -87654.321\ny <- pqnumber(-1,2,0,c(4,1,3)) # -3.14\nz <- pqnumber(1,1,3,c(7,3,2,5,6)) # 6523.7\nw <- pqnumber(1,3,5,c(3,1,2,4,5,3,8,7,7)) # 778354.213\n\nsubtract(x,z) # expected value: -94178.021 in pqnumber form\nsubtract(w,x) # expected value: 866008.534 in pqnumber form\nsubtract(y,z) # expected value: -6526.84 in pqnumber form\n\n```\n\n---\n\nPerhaps now we can write a different arithmetic function...?\n\n## c) Multiplication\n\nWe will try to define the product of two `pqnumber` objects.\n\n#### **`multiply()`**\n\n**Algorithm:**\n\n1. We first initialize a vector $z$ of length $x\\$p + x\\$q + y\\$p + y\\$q + 1$, which represents the maximum number of digits we can possibly obtain by multiplying two numbers (considering the case of a carry-over).\n\n2. Now, we iterate through each element of `nums` of $y$ and we multiply it with the entire `nums` vector of $x$ and place it in the appropriate indices of $z$.\n\n3. We use carry-over function to clear any carries.\n\n4. We determine the sign of the product by multiplying the sign of $x$ with the sign of $y$.\n\n5. We return the product as a `pqnumber` object.\n\n```{r}\n#| code-fold: true\n#| code-summary: \"Show the Code\"\n\nmultiply <- function(x,y) {\n  # This function multiplies two pqnumbers\n  # Args:\n  # x: a pqnumber\n  # y: a pqnumber\n  # Return:\n  # the product of x and y, returned in a pqnumber format\n  \n  n <- x$p + x$q + y$p + y$q + 1\n  z <- rep(0L, n)\n  \n  for (r in 1:(1+y$p+y$q)) {\n    \n    x_leftover <- x$p + x$q\n    z[r:(r+x_leftover)] <- z[r:(r+x_leftover)] + (x$nums*y$nums[r])\n  }\n  z <- carry_over(z)\n  digit_offset <- length(z) - n\n  sgn <- x$sign * y$sign\n  pqnumber(sgn, x$p + y$p, x$q + y$q + digit_offset, z)\n}\n\n``` \n\n**Test Cases:**\n```{r}\n\nx <- pqnumber(-1,1,1,1:3) # -32.1\ny <- pqnumber(-1,2,0,c(4,1,3)) # -3.14\nz <- pqnumber(1,3,2,c(3,1,9,4,5,7)) # 754.913\n\nmultiply(x,z) # expected value: -24232.7073 in pqnumber form\nmultiply(x,y) # expected value: 100.794 in pqnumber form\nmultiply(y,x) # expected value: 100.794 in pqnumber form\n\n```\n\n---\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":"html_document","warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","comments":{"giscus":{"repo":"jryu20/quarto"}},"theme":{"light":"flatly","dark":"darkly"},"title-block-banner":true,"title":"Objected Oriented Programming in R","author":"Jun Ryu","date":"2023-03-09","categories":["R","OOP"],"image":"https://upload.wikimedia.org/wikipedia/commons/b/b8/Lots_of_math_symbols_and_numbers.svg"},"extensions":{"book":{"multiFile":true}}}}}